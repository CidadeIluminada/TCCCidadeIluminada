http://www.ibta.com.br/images/logo.png

IBTA-BILAC - INSTITUTO BRASILEIRO DE TECNOLOGIA AVANÇADA DE SÃO JOSÉ DOS CAMPOS




Abstract


Este trabalho apresenta um estudo sobre dispositivos móveis, explicando a implementação de um protótipo de software que auxiliará no recebimento e análise de denuncias relacionados a iluminação pública na cidade de São José dos Campos. O aplicativo foi desenvolvido em Android e será responsável por enviar estas denuncias para um ambiente web. A aplicação web será responsável por responder às requisições do aplicativo Android e processa-las de modo que a manutenção dos pontos de iluminação pública seja feita de uma maneira mais rápida e menos burocrática .


Palavras-chave: Iluminação pública, Aplicativo Android, Sistema web para manutenção.
________________




ABSTRACT
This paper presents a study on mobile devices, explaining the implementation of a software prototype that will assist in receiving complaints and analysis related to street lighting in the city of São José dos Campos. The application was developed on Android and will be responsible for sending these complaints to a web environment. The web application will be responsible for responding to requests from the Android application and process them so that the maintenance of public lighting points is done in a faster and less bureaucratic way.




Keywords: Public lighting system, Android Application, web system for maintenance.




















































Índice de Figuras



________________


LISTA DE ABREVIATURAS E SIGLAS




EUA - Estados Unidos da América
ANEEL - Agencia Nacional de Energia Elétrica
URBAM - Urbanizadora Municipal
GPS - Sistema de Posicionamento Global
WAP - Protocolode aplicação Wireless
SQL - Structured Query Language
CRUD - Acrónimo de Create, Read, Update e Delete na língua Inglesa
PDF - Formato Portátil de Documento
HTML - HyperText Markup Language
SSH - Secure Shell
UTC - Tempo Coordenado Universal
API - Interface de Programação de Aplicativos
ORM - Mapeamento objeto-relacional
JSON - JavaScript Object Notation
MVC - Model-View-Controller
























































SUMÁRIO




INTRODUÇÃO
2. FUNDAMENTAÇÃO TEÓRICA
2.1 Engenharia de Software
2.1.1 Método de desenvolvimento Agile, Kanban e Scrum
2.2 Resolução Normativa 414
2.3 Desenvolvimento mobile
3. TECNOLOGIAS
3.1 Python
3.1.1 Flask
3.1.2 SQLAlchemy e Flask-SQLAlchemy
3.1.3 Flask-Migrate e alembic
3.1.4 Flask-Admin
3.1.5 Flask-Script
3.1.6 xhtml2pdf
3.1.7 fabric e fabtools
3.1.8 unicodecsv
3.1.9 Flask-Security
3.3.1 GSON
3.3.2 Joda-Time
3.3.3 Retrofit
3.3.4 Sugar
3.4 JavaScript
3.4.1 JSON
3.4.2 AngularJS
3.4.3 JQuery
3.5 Representational State Transfer (REST)
4. DESENVOLVIMENTO
4.1 APLICATIVO ANDROID E SEU SISTEMA DE GERENCIAMENTO
4.1.1 Backlog de atividades
4.1.2 Definição dos Sprints
4.1.3 Apresentação para a Secretaria de Obras
4.2 SISTEMA DE GERENCIAMENTO DE PONTOS DE ILUMINAÇÃO E ORDENS DE SERVIÇO
4.2.1. Entrevista inicial ao cliente
4.2.2 Requisitos do sistema
5. CONCLUSÃO
5.1 Conclusões
5.2 Trabalhos futuros



________________




1. INTRODUÇÃO


A Iluminação pública é um instrumento de cidadania, pois é um item essencial à qualidade de vida e a segurança dos centros urbanos, ajudando a preservar e embelezar os patrimônios públicos e a prática de diversas atividade noturnas no espaço público.
Segundo Aver[1] a falta de iluminação contribui consideravelmente com o aumento dos índices de criminalidade e a falta de segurança dos cidadãos que por algum motivo tem que transitar no período noturno por pontos sem iluminação, ou com iluminação precária. Estudos feitos pela organização Campbell Collaboration[2], mostraram que a melhoria na iluminação pública em algumas cidades do Reino Unido e EUA, ajudaram a reduzir a criminalidade em até 21%, e concluiu que esta melhoria promoveu o aumento da vigilância da comunidade, que atuou como elemento inibidor contra a criminalidade local.
Os responsáveis pela instalação e manutenção da iluminação pública dos municípios no Brasil mudou em dezembro de 2014. Até então, elas eram feitas pelo estado, normalmente através das concessionárias de energia elétrica. Agora é a própria prefeitura que tem a responsabilidade por garantir as lâmpadas acessas. Essa mudança foi ocasionada pela Resolução Normativa 414 [3], uma determinação constitucional expedida pela ANEEL (Agencia Nacional de Energia Elétrica) que obrigou todos os 5.570 municípios brasileiros a se responsabilizar pela manutenção da infraestrutura da iluminação pública.
A cidade de São José dos Campos/SP conta hoje com 56.688 pontos de iluminação distribuídos pela cidade. A média de lâmpadas com defeito é de 300 por mês, de acordo com a Secretaria de Obras da cidade [4]. Um dos maiores problemas a serem enfrentados é o recebimento de chamados para solucionar problemas com os postes defeituosos, já que o canal de reclamações da prefeitura engloba todos os problemas da cidade, causando assim, uma sobrecarga no atendimento.
A Urbanizadora Municipal (URBAM) foi a empresa contratada pela prefeitura de São José dos Campos para realizar a manutenção da iluminação pública do município. Com a proposta de auxiliar a URBAM no encontro dos pontos com problemas e agilizar as respostas aos chamados abertos pelos munícipes, o trabalho “Cidade Iluminada” apresenta uma solução de um aplicativo para smartphones e uma aplicação Web para a gestão das solicitações de manutenção dos pontos de iluminação pública.
O atual processo de recebimento de chamados, funciona de maneira manual, onde um funcionário deve entrar em um sistema do canal de recebimentos de denuncias, o 156, e coletar manualmente todas as denuncias recebidas no dia, colocar em uma planilha no Excel, e separar por regiões. Após este passo, a planilha já dividida em regiões, são checados os chamados um a um caso haja duplicidade. Uma vez que todos os pedidos já estão na planilha e caso não haja duplicidade, uma ordem de serviço é feita e enviada a URBAM para que a manutenção seja feita. Quando a manutenção é feita, esta ordem de serviço retorna e são retirados da planilha os chamados que foram atendidos.
Evidentemente é um processo muito complexo, e passível a erros, onde por um menor descuido vários detalhes poderão ser perdidos, como denuncias duplicadas que irão gerar o retrabalho quando a ordem de serviço é gerada. Por isso nós propomos uma solução, onde não será mais necessária a coleta e verificação manual de todas as denuncias. Todo este trabalho excessivo será reduzido e em poucos cliques toda a análise será feita automaticamente.
Nossa missão é disponibilizar uma ferramenta que irá aperfeiçoar o recebimento dos chamados relacionados aos postes de iluminação e viabilizar a comunicação do cidadão diretamente com a entidade competente  através de uma aplicação Android e um ambiente Web onde essas informações serão processadas . Neste aplicativo, o usuário poderá registrar o problema na rede pública de iluminação, enviar uma foto e a localização do problema e acompanhar o andamento do protocolo aberto por ele. No ambiente Web, este protocolo será analisado e separado de acordo com a região, bairro, rua e tipo de problemas, também serão analisados se não há duplicidade em algum ponto. E além disso, o sistema tem como função preparar a ordem de serviço para a manutenção, e fazer o controle dos materiais utilizados.
________________






2. FUNDAMENTAÇÃO TEÓRICA


2.1 Engenharia de Software


Segundo Pressman [15] Engenharia de software é definida como: “O estabelecimento e uso de sólidos princípios de engenharia para que se possa obter economicamente um software que seja confiável e que funcione eficientemente em máquinas reais.”
O termo Engenharia de software foi criado por volta da década de 60, com o objetivo de sanar a crise do software e contornar os problemas oriundos do grande crescimento da demanda de softwares e da complexidade a eles imposta, assim padronizando o desenvolvimento deixando-o mais controlado e sistemático.
Segundo Breitman [16] “o desenvolvimento de sistemas de software é uma atividade complexa que envolve um grande número de recursos, coordenados de modo a atingir um mesmo objetivo”.  Por isso esta tarefa exige um planejamento detalhado e documentado por se tratar de um objeto dinâmico que está sempre se adaptando as necessidades dos usuários de acordo com as ferramentas usadas no seu desenvolvimento
Para Pressman [15] a engenharia de software tem três fases: definição, desenvolvimento e manutenção.
A fase de definição, estabelece as propriedades, características, limitações e funcionalidades do software. Esta fase é dividida em três etapas, a análise do sistema onde são definidas as funções que o sistema deve apresentar. O planejamento de projeto, onde  são analisados os riscos, custos e recursos que serão necessários no desenvolvimento. E por fim a análise dos requisitos, nesta etapa são verificados os requisitos necessários para que atenda as funções do sistema.
A fase de desenvolvimento, é a parte onde os desenvolvedores transformas as especificações em código. O projeto é analisado, estabelecendo a arquitetura e estrutura dos dados, seguida pela codificação numa linguagem de programação que atenta as necessidades do projeto.
E finalmente a fase de manutenção dedica-se a aprimorar ainda amais o sistema, sendo validado pelo usuário final, que nem sempre está satisfeito. Algumas mudanças podem ocorrer no projeto final, como correções pontuais que acontecem quando usuário acha um erro, adaptações caso novos atributos precisarem ser adicionados, e por fim o aprimoramento funcional, que acontece a medida que o usuário se acostuma a utilizar o sistema, e poderá sugerir novas funcionalidades.
2.1.1 Método de desenvolvimento Agile, Kanban e Scrum


O Agile foi publicado em 2001 por meio da publicação de um manifesto por Jeff Sutherland, Ken Schwaber et. al. que priorizava a rápida adaptação às novas situações, a colaboração entre si dos times de desenvolvimento, a colaboração dos times de desenvolvimento com os seus clientes e a entrega de softwares que estejam funcionando. [5]
Apesar do Agile não ditar como o desenvolvimento deva ser feito por si só, ele é um conjunto de conceitos para que métodos, como o Kanban e o Scrum, sejam construídos.
O Scrum consiste basicamente em separar atividades de trabalho em sprints, com o objetivo de entregar todas as atividades da forma mais completa possível, trabalhando assim de modo incremental a cada sprint até que o cliente decida que o software esteja com uma qualidade suficiente para ser entregue. Além disso, seguindo os princípios dos métodos Agile, o Scrum ajuda na colaboração intra-equipe por meio de reuniões stand-up diárias e uma reunião pós-sprint de retrospectiva e uma reunião pré-sprint para planejamento do próximo sprint. Para facilitar o planejamento, existem somente três “papéis” no Scrum: O Dono do Produto (Product Owner), o Mestre do Scrum (Scrum Master) e a Equipe (Team).
A Equipe consiste nos desenvolvedores que irão efetivamente fazer a implementação do produto baseado nas necessidades do Dono, que é responsável por demonstrar os seus requisitos. O Mestre do Scrum é responsável por além de transformar os requisitos do Dono em atividades que podem ser divididas entre os membros da Equipe, é responsável principalmente por gerenciar a equipe para que as atividades sejam cumpridas em cada sprint. [6]
O Kanban é uma técnica que separa as atividades em estados pré-definidos pela equipe que a utiliza, e é utilizada principalmente para visualizar o progresso de diferentes atividades dentro de um contexto. Por si só, o Kanban não diz como introduzir novos processos, mas sim como montar os processos existentes, como o Scrum, de forma visual.
2.2 Resolução Normativa 414




A Agência Nacional de Energia Elétrica (Aneel), determinou que a partir de janeiro de 2015, a responsabilidade da manutenção da iluminação pública será do município. Esta resolução vem de uma determinação da Constituição Federal de 1988 que, em seu artigo 149-A e conforme Emenda Constitucional número 39, de 19 de dezembro de 2002. A partir desta data limite, o município terá que arcar também com os investimentos para a ampliação e modernização da rede, instalação de medidores de acordo com a concessionária e também a manutenção do cadastro de ativos georreferenciados.
A responsabilidade da manutenção da rede até então era das concessionarias de distribuição de energia elétrica locais. E segundo um sondagem da Confederação Nacional dos Municípios (CNM), esse transferência poderá aumentar aproximadamente até 28% a despensa anual dos municípios.[17]
2.3 Desenvolvimento mobile


Durante as últimas décadas foi notável o aumento significativo do uso de dispositivos móveis, segundo o grupo Ibope[12], com diversas funções e finalidades específicas, como computadores de bolso, smartphones, telefones celular, consoles portáteis combinado com as mais diversas tecnologias como GPS, navegadores de Internet, WAP, leitores de áudio, vídeo e texto, entre outros, e juntamente com a evolução das tecnologias e o aumento do poder computacional tornou-se possível o desenvolvimento de aplicações independentes do hardware ou software do dispositivo.
Na América Latina não foi diferente, até o ano de 2014 o Brasil possuía certa de 137 milhões de usuário,um pouco mais de 67% da população, segundo pesquisa conduzida pela eMarketer [19], que ainda prevê um aumento de mais 4 milhões de usuários até o final de 2015.
Com base nesses dados é irrefutável o crescimento do mercado neste segmento o que propicia muitas oportunidades no desenvolvimento de aplicativos mobile. É visível a necessidade de encontrar novas soluções para os usuários de smartphones, e integrar novas tenologias a este mercado, pois a necessidade não para de crescer junto com  número de usuários.
________________
3. TECNOLOGIAS
3.1 Python


Python é uma linguagem de programação multiparadigma (se destacando os paradigmas orientado a objetos e funcional) , interpretada, imperativa e de alto nível; possui tipagem dinâmica e código fonte livre[9] e gratuito, que pode ser facilmente encontrado na Internet e podendo ser livremente modificado e redistribuído, e também possui fácil integração com outras plataformas como .NET, Java e C/C++.
A linguagem foi originalmente concebida e implementada pelo holandês Guido Van Rossum no final de 1990 [10], e a ideia original era de criar um sucessor para a linguagem ABC.
Uma das grandes vantagens de utilizar o Python é devido à comunidade que surgiu ao redor da linguagem, ocasionando portanto, em um grande número de bibliotecas (cerca de 70,000 pacotes, de acordo com o repositório central Python Package Index)[20] tanto open-source como bibliotecas de livre utilização.
O Python foi escolhido para a implementação, junto com o framework web Flask,  devido a sua facilidade e velocidade de implementação, além de experiência anteriores com o Python e com o framework Flask.
3.1.1 Flask
Flask é um microframework para desenvolvimento web, criado em Python baseado em duas ferramentas Werkzeug e Jinja2. O Flask mantém o núcleo simples e, para isso, ele suporta extensões que são capazes de adicionar diversas funcionalidades a aplicação como por exemplo suporte a banco de dados, camadas de cache, geração de formulários, etc..[21]
Existem vários outros frameworks de desenvolvimento web para Python, como por exemplo o Django, Pyramid, Tornado, entre outros.  O Flask foi escolhido devido a sua grande capacidade de extensão e por causa de experiências anteriores com o desenvolvimento de aplicativos Web.




3.1.2 SQLAlchemy e Flask-SQLAlchemy
O SQLAlchemy é um conjunto de ferramentas para operar com SQL no Python de forma abstrata, englobando assim um ORM e um conjunto de ferramentas para a utilização do SQL no Python de forma natural para os usuários de Python. [22]
Além disso, o SQLAlchemy abstrai os principais bancos de dados, como o MySQL, PostgresSQL, Oracle e até mesmo SQLite. Isso permite a codificação do acesso ao banco de dados da aplicação sem precisar depender de qual banco específico.
A integração do Flask com o SQLAlchemy se dá por meio da extensão Flask-SQLAlchemy, e ela tem como objetivo principal facilitar a configuração do SQLAlchemy para a sua utilização em aplicativos Flask. [23]
O SQLAlchemy e o Flask-SQLAlchemy foram escolhidos devido a sua grande flexibilidade e poder expressivo dentro de sua linguagem, além de sua fácil integração com o Flask.
3.1.3 Flask-Migrate e alembic
O alembic é uma ferramenta que trabalha junto com o SQLAlchemy para a geração e execução de migrações de banco de dados. Isso permite que alterações feitas no código das classes sejam refletidas na estrutura de tabelas no banco de dados de forma semi-automática. [24]
O Flask-Migrate é a biblioteca de integração do alembic com o Flask. Isso expõe ao Flask comandos que facilitam o gerenciamento destas migrações[25].
O alembic foi escolhido não somente pela sua fácil integração com tanto o SQLAlchemy e o Flask, mas também por ele ser uma ferramenta de gerenciamento de migrações de alta qualidade.
3.1.4 Flask-Admin
O Flask-Admin é uma extensão do Flask que auxilia a criação de páginas de gerenciamento do back-end de aplicativos em Flask. Isso é feito expondo aos programadores utilidades que geram telas administrativas genéricas para que então cada aplicação as customize de acordo com suas necessidades. [26]
O Flask-Admin foi escolhido para ser a base das telas do sistema de gerenciamento de ordens de serviço pois grande parte das funcionalidades básicas necessárias para um sistema CRUD já estão maduras no Flask-Admin.
3.1.5 Flask-Script
O Flask-Script disponibiliza um conjunto de ferramentas e classes para o gerenciamento da aplicação Flask.
Inicialmente, o Flask-Script disponibiliza comandos para o gerenciamento do servidor de desenvolvimento e disponibiliza estruturas para que cada aplicação possa implementar seus próprios comandos. [27] Além disso, o Flask-Script integra o Flask-Migrate disponibilizando comandos para preparar e executar migrações de banco de dados.
O Flask-Script foi escolhido para realizar a integração pois ela atende satisfatoriamente à demanda de auxílio no gerenciamento da aplicação.
3.1.6 xhtml2pdf
O xhtml2pdf é uma biblioteca que tem como objetivo transformar páginas HTML preparadas para o formato PDF.[28]
A biblioteca foi utilizada para gerar as tabelas das ordens de serviço para compartilhar  com a URBAM os endereços dos postes de cada ordem de serviço gerada.
Essa biblioteca foi utilizada pois ela era a mais conveniente de ser utilizada dado o fato que o Flask contém um renderizador de templates HTML.
3.1.7 fabric e fabtools
O fabric é uma utilidade que tem como objetivo executar comandos de gerenciamento de servidores via SSH. A grande vantagem de sua utilização é automatizar tarefas de lançamento da aplicação ou até mesmo a preparação de ambientes de produção.[29]
O fabtools é uma biblioteca que expande o fabric para que a escrita de scripts fabric seja ainda mais fácil. Para isso, o fabtools expõe comandos para as ferramentas mais utilizadas, como comandos do sistema de arquivos, gerenciamento de pacotes de instalações, git, banco de dados, etc.. [30]
O fabric e fabtools foram escolhidos para serem utilizados devido experiências positivas anteriores de gerenciamento de servidores.
3.1.8 unicodecsv
O módulo csv do Python é disponibilizado na biblioteca padrão do Python para a leitura e escrita de arquivos separados por vírgula. Porém, devido às dificuldades do Python 2.7 para a leitura e uso de textos com codificação em Unicode, surgiram várias bibliotecas que vieram para suplantar os módulos da biblioteca.
Uma dessas bibliotecas e justamente o unicodecsv, que simplesmente faz o tratamento de textos em Unicode para que não ocorra erros na leitura e escrita desses arquivos com a codificação Unicode.[31]
Ela foi escolhida pois, além de atender perfeitamente essa demanda, ela tem uma grande facilidade no seu uso, pois a sua interface e idêntica ao módulo csv padrão do Python
3.1.9 Flask-Security


O Flask-Security é a integração de uma série de bibliotecas do Flask relacionadas ao controle de acesso de usuários com o objetivo de facilitar a implementação desse tipo de sistema.
Apesar de sua baixa flexibilidade, o Flask-Security foi escolhido para ser usado no controle de acesso pois ele realmente facilita a implementação e manutenção desse aspecto.
.
3.3.1 GSON


GSON é uma biblioteca do Google para a serialização e deserialização de objetos Java arbitrários. O objetivo desta biblioteca, além de prover essas conversões, é trabalhar com objetos que o programador não necessariamente tem o código-fonte disponível, mantendo uma interface simples (métodos fromJson e toJson) para quando for precisar converter de e para JSON. [33]
A biblioteca foi utilizada pois ela atende a necessidade principal de tratar JSON mas ainda sendo relativamente fácil de utilizar e configurar as classes que precisam dessa conversão.
3.3.2 Joda-Time


A biblioteca Joda-Time tem como objetivo retirar algumas dificuldades que a linguagem Java possui na sua biblioteca padrão de manipulação de tempos e datas.
Ela foi utilizada para a geração de timestamps em UTC para marcar o envio das requisições do aplicativo e para gerar os nomes de arquivos das fotos tiradas pelo aplicativo. A  biblioteca Joda-Time foi escolhida para substituir a biblioteca padrão do Java nas suas proximas versões.[34]
3.3.3 Retrofit


A biblioteca Retrofit tem como objetivo disponibilizar ferramentas para que se possa definir APIs REST como interfaces Java para serem então usadas no código da aplicação sem maiores dificuldades. Além disso, ela disponibiliza modos de fazer requisições síncronas ou assíncronas, dependendo das necessidades de cada aplicação.[35]
A biblioteca Retrofit foi utilizada devido a sua facilidade de utilização e adaptação à API já definida do trabalho. Houve uma primeira tentativa de implementação utilizando a biblioteca Unirest, mas devido a dificuldades de compilação da biblioteca para utilização no ecossistema Android a Unirest foi substituida pela Retrofit.[36]
3.3.4 Sugar
Sugar é uma biblioteca que tem como objetivo a ser uma ORM especificamente para aplicações Android, tendo uma interface por objetos e classes com o banco de dados SQLite do dispositivo. Além disso, ela tem a pretensão de ser simples de usar e simples de configurar. Alem disso, ela possui suporte à migraçoes de banco automáticas.[37]
O Sugar foi escolhido justamente devido a sua simplicidade tanto na configuração quanto no seu uso dentro do codigo.
3.4 JavaScript
JavaScript é uma linguagem dinâmica, funcional e orientada a objetos, suas aplicações são distribuídas somente em forma de código fonte, e é executada em todos os navegadores modernos com poucas ou nenhuma diferença de plataforma. Isso é especialmente importante nos dias atuais pois até mesmo smartphones têm o seu próprio navegador, abrindo então uma nova plataforma inteira de aplicações
Em 1994, foi fundada uma empresa chamada Netscape, e um dos principais objetivos dela foi a exploração da Web nascente, e sua então nova necessidade de serem disponibilizadas páginas dinâmicas. Um exemplo disso foi a necessidade de validação de formulários: O usuário teria que preencher todo o formulário, enviá-lo e então receber o retorno do servidor se falhou ou não. Em 1995, em uma parceria com a Sun, a Netscape decidiu que esta nova linguagem teria que ter uma sintaxe parecida com a liguagem Java, descartando assim a liguagem Python (entre outras) como candidatas para ser implementadas em seu navegador.
Brendan Eich foi contratado para implementar a liguagem Scheme no navegador, porém, por causa dessa decisão da Netscape, ele acabou implementando a liguagem que seria conhecida como JavaScript (o nome oficial é ECMAScript) em 10 dias. [8]
Apesar de seu surgimento rápido, a linguagem foi passando por várias alterações que a deixam muito mais poderosa e mais em linha com as necessidades atuais de desenvolvimento para a Web moderna.
O JavaScript foi escolhido para a implementação de páginas Web dinâmicas no projeto principalmente pelo fator de ele ser suportado pelos principais navegadores existentes no mercado, como o Mozilla Firefox, o Google Chrome e o Internet Explorer, sendo os dois primeiros softwares livres para a utilização em ambientes pessoais ou corporativos.
3.4.1 JSON
JSON (JavaScript Object Notation) é um formato para guardar e transmitir dados em texto que foi descoberto e formalizado por Douglas Crockford em 2001. [37] Desde então vem ganhando popularidade como um formato de troca de dados entre aplicações web. Existem bibliotecas para a leitura do formato JSON para a maioria das linguagens de programação, além do suporte praticamente nativo no JavaScript e Python.
O JSON foi escolhido como método de troca de dados pois ele tem suporte praticamente nativo em JavaScript e Python, além de ser mais eficiente em termos de quantidade de bytes enviados do que XML para envio de dados mais simples.
3.4.2 AngularJS
AngularJS é um framework do tipo MVC (Model-View-Controller) JavaScript que tem como objetivo facilitar o desenvolvimento web, estendendo e adaptando o HTML para melhorar a experiência de desenvolvimento de páginas Web altamente dinâmicas. Esta framework foi criada em 2009[11] por  Miško Hevery e Adam Abrons, e é open-source.
O framework foi utilizado na criação da página de controle dos protocolos oriundos da aplicação Android, sendo parte fundamental da parte em tempo real desta página.
O AngularJS foi escolhido devido a sua grande capacidade de facilitar o desenvolvimento e manutenção de páginas Web altamente interativos.
3.4.3 JQuery


JQuery é uma biblioteca JavaScript que tem como objetivo principal facilitar a seleção e manipulação de documentos HTML e o controle de eventos nas páginas. Além disso, o JQuery disponibiliza uma API única para todos os navegadores principais. [38]
O JQuery foi utilizado em várias das páginas da parte de gerenciamento de protocolos e serviços, pois ela se tornou quase como a biblioteca padrão para se manipular páginas HTML por JavaScript. O principal uso da biblioteca se deu na página de criação de Ordens de Serviço, onde a parte de seleção de postes foi implementada em JQuery.
3.5 Representational State Transfer (REST)
O REST é um estilo de arquitetura para aplicações Web proposta por Roy Thomas Fielding em sua dissertação de PhD. [39] Esta tese tinha como objetivo de, além de propor esse tipo de arquitetura, avaliar se serviços disponíveis na Web até então seguiam os quesitos seguintes:
* Cliente-Servidor: A aplicação teria que manter independentemente suas implementação de clientes (interface gráfica, por exemplo) da implementação dos serviços oferecidos por ela (banco de dados, por exemplo)
* Sem estado: Isso significa que, a cada requisição enviada para o servidor, esta teria que incluir todos os dados para que a própria seja entendida, sem que o servidor precise depender de informações que por ventura ele possa ter armazenado anteriormente.
* Cacheável: Cada resposta a uma requisição tem que deixar explícito se é permitido guardar a resposta em um cache no cliente. A ideia é que, se o cliente precisar refazer uma requisição equivalente, esta requisição deveria utilizar o cache ao invés de ser enviada para o servidor.
* Interface uniforme: De acordo com Fielding em sua dissertação, é a característica fundamental que aplicações REST têm de implementar. Ela consiste em padronizar todos os componentes para que as implementações de clientes e serviços sejam simplificados.
* Sistema em camadas: Cada componente deve não conhecer ou depender de componentes de que este componente não precise interagir. A principal vantagem, de acordo com Fielding, é que o sistema em camadas pode ser usado para encapsular clientes e serviços legados
* “Code-on-demand”: A aplicação REST teria que oferecer um conjunto de recursos que viriam como código a ser executado no cliente. Este código seria como uma interface mínima da aplicação para o cliente consumir. A principal vantagem de implementar o Code-on-demand seria que, a parte básica da API não precisaria ser reimplementada pelo cliente. É o único quesito opcional para que uma interface fosse considerada como REST.




________________






4. DESENVOLVIMENTO
O desenvolvimento do trabalho pode ser separado em duas fases e períodos distintos, sendo estes o desenvolvimento do aplicativo para smartphones Android e o sistema de gerenciamento dos protocolos deste, e o desenvolvimento do sistema de gerenciamento de pontos de iluminação e de seus serviços e chamados.
4.1 APLICATIVO ANDROID E SEU SISTEMA DE GERENCIAMENTO
Para o desenvolvimento do aplicativo para smartphones Android e seu sistema de gerenciamento, foram aplicadas os métodos Agile de desenvolvimento Scrum e Kanban.
As atividades a serem cumpridas foram determinadas no início do projeto, e foram divididas em três categorias, e priorizadas dependendo da importância de cada atividade para o cumprimento do projeto.
Em relação à execução das atividades, elas foram divididas em 5 “sprints”, que foi um período de 14 dias em que as atividades selecionadas para fazer parte do sprint teriam que ser cumpridas. Para determinar quais atividades entrariam em cada sprint, foi usado primeiramente o critério da prioridade de cada atividade, e secundariamente, o tempo estimado para o término da atividade.
4.1.1 Backlog de atividades
O backlog de atividades é o repositório inicial das atividades, e onde cada atividade foi posta em uma das três categorias de desenvolvimento, App, Webservice e Site Secretaria. Além disso, cada atividade recebeu uma pontuação de 1 a 15, que determinava a prioridade daquela atividade. 1 é a atividade mais prioritária.


App
	Webservice
	Site Secretaria
	8 - Tela Principal
9 - Incluir protocolos anônimos
10 - Cadastro de usuário
11 - Incluir protocolos cadastrados
12 - Gravar off-line protocolos para envio posterior
15 - Listar protocolos
	7 - Incluir protocolos
13 - Consultar protocolos
14 - Listar protocolos
	1 - Criar Banco de Dados
2 - Página inicial
3 - Cadastro de usuário
4 - Controle de acesso
5 - Visualizar protocolos
6 - Mudar status protocolos
	4.1.2 Definição dos Sprints
Um sprint é um período previamente acordado pelo time Agile onde o sistema é de fato implementado. Este período pode variar de acordo com cada equipe, mesmo em equipes dentro da mesma organização ou empresa.
Para o desenvolvimento do sistema de gerenciamento dos protocolos e do aplicativo Android, cada sprint teve duração de 14 dias, onde foram escolhidos várias atividades de acordo com os critérios da sua prioridade de implementação e sua facilidade de implementação dada a situação que o projeto se encontrava.
* Sprint I:
O primeiro sprint foi feito a modelagem e a implementação do banco de dados, assim como o layout e a wireframe do ambiente web.
* Sprint II:
Nesta segunda etapa foi feita a criação do layout e padronização da interface do ambiente web. Também foram implementados os serviços de criação e inclusão dos protocolos.
* Sprint III:
Implementação das telas do aplicativo Android, e do fluxo principal de telas, também como a funcionalidade de ativar a câmera do aparelho, também foi implementado uma funcionalidade que busca automaticamente a localização do aparelho que está enviando o reporte
* Sprint IV:
Este sprint foi focado na implementação das funcionalidades do aplicativo como o cadastro do usuário, tela de configurações e status dos protocolos enviados
* Sprint V:
No último sprint foram acertado os últimos detalhes do aplicativo, como gravação dos protocolos off-line para envio posterior, busca do status do protocolo e foi finalizado o design da aplicação.
4.1.3 Apresentação para a Secretaria de Obras
Após a finalização da primeira versão do aplicativo e do ambiente web do projeto “Cidade Iluminada”, fomos convidados a apresentar nossa solução para o Secretário de Obras de São José dos Campos, o senhor Rene Mina Vernice e sua equipe, na data de 14 de Setembro de 2015.
Inicialmente, a ideia do aplicativo não foi bem aceita, pois foi alegado que isso geraria ainda mais trabalho para os funcionários responsáveis por recolher as denuncias relacionadas a iluminação pública. Apesar disso, o conceito do ambiente web para gerenciamento foi bem recebido, pois eles enfrentam muitas dificuldades administrando os chamados já existente.
4.2 SISTEMA DE GERENCIAMENTO DE PONTOS DE ILUMINAÇÃO E ORDENS DE SERVIÇO
4.2.1. Entrevista inicial ao cliente
Anteriormente a primeira entrevista, foi realizada uma apresentação do conceito do projeto para o Secretário de Obras Renê Vernice e outros integrantes da equipe. O conceito do projeto foi não bem aceito por todos, pois a Secretaria de Obras não atenderia os chamados abertos pelo aplicativo. Foi acordado que o projeto seguiria, caso fossem feitas algumas modificações que ajudassem na organização dos serviços realizados nos pontos de iluminação.
Posteriormente, foi feita uma reunião com a assistente do Secretário, a senhora Cintia Firmino para entendermos melhor o funcionamento do processo atual.
            1). Como é o processo atual?
Processo de atualização feito a partir da coleta manual do sistema 156, e colocado numa planilha para o tratamento de pedidos duplicados e separação dos casos por zona e bairro.
         2) Como vocês recebem as chamadas dos postes com defeitos?
Os chamados vêm do sistema 156, ou por memorando de Vereadores que tem prioridade, não possui um canal personalizado apenas para eles vem do sistema 156 (156 possui resposta programada)
3). Como é feita a ordem de serviço?
A ordem de serviço é feita pelo Excel, separando os chamados por zona, bairro e rua. E após isso esta planilha é enviada para a empresa URBAM por e-mail.
4). Vocês acham que é o melhor processo? Como poderia melhorar?
O processo poderia melhorar se os protocolos já chegassem a nós separados pela região, sem duplicidade, com a data . Sem a necessidade de analisar todos os pedidos que vem do 156
5). Qual seria o processo ideal?
Receber os protocolos separados pela região, bairro e rua, sem duplicidade. Responder ao munícipe automaticamente.
6). Vocês separam 'os postes por tipos? Quais tipos?
Temos dois tipos, a iluminação ornamental, e a iluminação de vias.
7). Como vocês agrupam postes da mesma rua? Vocês têm uma base de dados de endereços?
Os postes são agrupados em até 10 números da mesma rua. Há problemas também em verificar os endereços das praças e vielas pois tem mais de um endereço (vielas e praças não, consta no Google problema de localização das lâmpadas ornamental).
8). Vocês agrupam as situações das pendências (resolvida, não resolvida, enviada para serviço, 'etc.)? Se não, como seria o ideal?
Sim, por planilha, quando uma ordem de serviço e é mandada, os pedidos são retirados de uma planilha e colocadas em outra sinalizando que foram mandados e estamos esperando a resposta da URBAM.
9). Vocês agrupam os tipos de serviços das pendências (troca de lâmpada, troca de reator, etc.)? Se não, como seria o ideal?
Existem 3 tipos de serviços que nós justo com a URBAM, a troca de lâmpada, a troca de reator, e a troca da fotocélula.
O que será trocado é analisado um a um, pela URBAM que depois reporta o que foi trocado.
10). Como é feita a identificação de cada poste dentro de uma rua? Pelo número aproximado da casa?
Ainda não existe um sistema de identificação no momento.
11). Existe algum código para identificar os postes? Se não, o código ideal deve informar o quê?
Não existe, é pelo número da casa mais próxima ao poste.
12). Vocês atualizam informações sobre cada ocorrência após o retorno da ordem de serviço? Se sim, o que vocês atualizam?
Sim, a URBAM retorna uma planilha com as tarefas executadas e o que foi trocado, e após, estas informações são colocadas numa planilha chamada “Executados”, e depois é respondido para o munícipe no 156.
4.2.2 Requisitos do sistema


Quando pensamos em qualidade de software, o foco está em entender os requisitos estabelecidos para assim evitar, ou minimizar a insatisfação do cliente final. Segundo Carvalho, Tavares [14] “A demanda por qualidade tem estimulado a comunidade de software para o desenvolvimento de modelos que conduzam a qualidade dos sistemas. Existe uma forte ligação entre requisitos e qualidade. ”
Em um sistema computacional, os requisitos definem o escopo e os serviços que o sistema deve oferecer, assim como as restrições que são aplicáveis a suas operações.


De acordo com as respostas levantadas na reunião com a Cíntia, foram então levantados os seguintes requisitos funcionais:
RF01: O sistema deverá fazer a coleta automática dos protocolos no sistema do 156 direcionados para a secretaria de obras.
RF02: O sistema deverá fazer essa coleta e, de acordo com a informação de cada protocolo, separar em bairros e regiões corretas para cada endereço.
RF03: O sistema deverá fazer a coleta sem adicionar protocolos em duplicidade. Dois ou mais protocolos em duplicidade se caracterizam por se referirem ao mesmo ponto de iluminação pública, tendo em vista que os postes são agrupados logicamente de 10 em 10 metros na rua. Por exemplo, se um protocolo se referir a um poste no número 10 da rua, e outro protocolo se referir a um poste no número 12 da rua, isso seria o mesmo poste.
RF04: O sistema deverá tentar ligar a cada protocolo a um poste, caso isso falhe, os sistemas devem permitir que o usuário faça essa correção manualmente.
RF05: O sistema deverá gerar a ordem de serviço em formato de planilha com, no máximo 50 pendências. Na geração da ordem de serviço, o sistema deverá dar preferência em agrupar protocolos do mesmo bairro e da mesma região da cidade.
RF06: O sistema deverá permitir a atualização da situação de execução e qual foi o tipo de manutenção realizada de cada protocolo das ordens de serviço.
RF07: O sistema deverá identificar as ordens de serviço que foram executadas para que o munícipe seja alertado.
RF08: O sistema deverá permitir que se faça buscas na base de postes e protocolos.
________________






5. CONCLUSÃO


5.1 Conclusões


A gestão de pendencias relativas a iluminação pública da prefeitura de São José dos Campos é burocrática, o que reflete na lentidão do atendimento e manutenção de um serviço tão essencial ao bem estar e segurança da população. O fato da responsabilidade pela manutenção ter sido passada para as prefeituras recentemente também é um fator crítico no desempenho do atendimento, já que as prefeituras tiveram que se adaptar rapidamente.
Partindo desta problemática, incentivados pela ideia de agilizar este processo, desenvolvemos o projeto Cidade Iluminada, onde o ambiente web, que que passou pela validação da equipe da Secretaria de Obras da Prefeitura Municipal de São José dos Campos provou reduzir a carga de trabalho e facilitar o recolhimento e análise das denuncias recebidas, automatizando um trabalho que era feito manualmente.
Infelizmente o aplicativo ainda não será disponibilizado para os munícipes a pedido do cliente, que alega que este canal de denuncias poderia  neste primeiro momento congestionar os recebimentos de denuncias já que a equipe ainda não possui um processo estruturado para a demanda, o aplicativo será usado por funcionários para a identificação de pontos de iluminação defeituosos.


5.2 Trabalhos futuros

Como trabalho futuro, foi proposto que o aplicativo seja liberado para o uso dos munícipes, integrando ao ambiente web para que ele receba as denúncias diretamente. Para que o aplicativo seja liberado, também é necessário que além de Android seja desenvolvido para iOS assim alcançando todos os públicos.
Relacionado ao trabalho em questão, seria interessante que futuramente novas funcionalidades sejam integradas, utilizando o aplicativo para outras utilizações além de denuncias relacionadas a iluminação pública.
Uma outra possibilidade é a melhoria da interface gráfica, tornando o ambiente web mais amigável para o uso de funcionários com vários níveis de conhecimento.








REFERÊNCIAS


[1] x
[2] x
[3] x
[4]  Comparativo mercado Android Brasil - http://www.kantarworldpanel.com/global/News/Android-Switchers-Drive-iOS-Growth-in-Europes-Big-Five-Countries
[5]
http://www.agilemanifesto.org/
[6] https://www.scrumalliance.org/why-scrum/core-scrum-values-roles?gclid=CjwKEAjwpaqvBRCxzIGoxs6v2TkSJADel-MIzZiwKysiX_QU25cWumb4QQi5ae356H3APHD-R79FNRoCJaXw_wcB
[7]
NIEMEYER, Patrick, LEUCK, Daniel. Learning Java. 4ª Edição. 1005 Gravenstein Highway North, Sebastopol, CA 95472: O’Reilly Media, Inc., 06/06/2013. 1010 pgs. (Série Nutshell)
[8]
RAUSCHMAYER, Axel. Speaking JavaScript. 1´ Edição. 1005 Gravenstein Highway North, Sebastopol, CA 95472: O’Reilly Media, Inc., 20/02/2014. 460 páginas. (Série Nutshell)
[9]
 Python License. Disponível em: https://www.python.org/psf/license.html. Acesso em: 07 setembro 2015.
[10]
Python history. Disponivel em: http://python-history.blogspot.com.br/2009/01/brief-timeline-of-python.html. Acesso em: 07 setembro 2015.
[11]
https://pt.wikipedia.org/wiki/AngularJS#Hist.C3.B3rico_de_Desenvolvimento
[12]
http://www.correiobraziliense.com.br/app/noticia/tecnologia/2015/03/12/interna_tecnologia,475253/estudo-aponta-aumento-na-penetracao-de-smartphones-na-america-latina.shtml
[13]
http://www.aneel.gov.br/cedoc/ren2010414.pdf
[14]
http://www1.serpro.gov.br/publicacoes/tematec/pubtem60.htm
[15] x
[16] x
[17] http://www2.camara.leg.br/atividade-legislativa/comissoes/comissoes-permanentes/cdu/noticias/norma-da-aneel-sobre-iluminacao-publica-prejudica-municipios-diz-confederacao
[18]
http://www.statista.com/statistics/262167/market-share-held-by-mobile-operating-systems-in-brazil/
[19] http://www.emarketer.com/Article/Nearly-400-Million-Latin-America-Used-Mobile-Phones-2014/1011818
[20]
https://pypi.python.org/pypi
[21]
http://flask.pocoo.org/docs/0.10/
[22]
http://www.sqlalchemy.org/features.html
[23]
https://pythonhosted.org/Flask-SQLAlchemy/
[24]
https://alembic.readthedocs.org/en/latest/
[25]
https://flask-migrate.readthedocs.org/en/latest/
[26]
https://flask-admin.readthedocs.org/en/latest/
[27]
https://flask-script.readthedocs.org/en/latest/
[28]
https://github.com/xhtml2pdf/xhtml2pdf
[29]
http://www.fabfile.org/
[30]
http://fabtools.readthedocs.org/en/latest/index.html
[31]
https://github.com/jdunck/python-unicodecsv
[32]
https://pythonhosted.org/Flask-Security/
[33]
https://github.com/google/gson
[34]
http://www.joda.org/joda-time/
[35]
http://square.github.io/retrofit/
[36]
http://stackoverflow.com/questions/29434271/could-not-find-class-javax-naming-ldap-ldapname-referenced-from-method-com-ma
[37]
https://github.com/satyan/sugar
[38]
https://jquery.com/
[39]
http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
[40]
http://rest.elkstein.org/










[Livro]
SOBRENOME, PRENOME abreviado. Título: subtítulo (se houver). Edição (se houver). Local de publicação: Editora, data de publicação da obra. Nº de páginas ou volume. (Coleção ou série)


São José dos Campos
2015
